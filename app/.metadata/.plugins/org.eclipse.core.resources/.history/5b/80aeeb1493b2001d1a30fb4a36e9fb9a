/*
 * main.c
 *
 *  Created on: 2023éª??2é??3é??
 *      Author: LZ
 */


//gccéå›§å™?¾¶å­˜æƒæµ??
#include <sys/mman.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <linux/ioctl.h>
#include <unistd.h>
#include <string.h>

//HPSé˜å‚šî†é»æ„?·µé¨å‹«ç°³çå‚šç•¾æ¶”å?ã”é‚å›¦æ?
#define soc_cv_av //å¯??é™æˆé’©é™ç™ˆyclone V ç»??å?

#include "hwlib.h"
#include "socal/socal.h"
#include "socal/hps.h"
#include "hps_0.h"

#define HW_REGS_BASE (ALT_STM_OFST)     //HPSæ¾¶æ ¬î†•é¦æ¿æ½ƒå¨ˆé›ç†?é¦æ¿æ½?
#define HW_REGS_SPAN (0x04000000)		//HPSæ¾¶æ ¬î†•é¦æ¿æ½ƒå¨ˆé›æ¹´é§?ç»Œæ´ªæ£? 64MBæ¾¶Ñƒçš¬
#define HW_REGS_MASK (HW_REGS_SPAN - 1) //HPSæ¾¶æ ¬î†•é¦æ¿æ½ƒå¨ˆé›æ¹´é§?éºâ•ƒçˆ?

#define AMM_WR_MAGIC 'x'
#define AMM_WR_CMD_DMA_BASE _IOR(AMM_WR_MAGIC, 0x1a, int)


#define IMG_WIDTH  400		//é¥å‰§å¢–ç?¹è—‰å®? 	RGB888
#define IMG_HEIGHT 320		//é¥å‰§å¢–æ?æ¨ºå?

#define IMG_SIZE IMG_WIDTH*IMG_HEIGHT*3/4		//å›¾åƒæ‰?å å†…å­˜å¤§å°? int å? IMG_SIZE

static volatile unsigned long *cfg_virtual_base = NULL;
static volatile unsigned long *_dma_base = NULL;
static volatile unsigned long *dma_base = NULL;

int fpga_init(int *virtual_base)
{
	void *per_virtual_base;
	//unsigned long dma_base;
	int dma_fd;
	int fd;
	//1.éµæ’³ç´‘mmu

	//çå——æ¹´é§?ç»Œæ´ªæ£¿é„çŠ²çš é’æ‰®æ•¤é´é£â”–é—??

	fd = open("/dev/mem",(O_RDWR|O_SYNC));
	if(fd == -1)
	{
		printf("fd = %d,ERROR:mmu open is failed\n",fd);
		return(0);
	}

	per_virtual_base = (unsigned int*)mmap(NULL,HW_REGS_SPAN,( PROT_READ | PROT_WRITE ),MAP_SHARED,fd,HW_REGS_BASE);
	printf("%x\n",per_virtual_base);

	dma_fd = open("/dev/vcam",O_RDWR);	// "/dev/amm_wr"	å¨Œâ„ƒæ¹ç’æƒ§î˜¬é‚å›¦æ¬¢é”›å²ƒç¹‘é??-1
	if(dma_fd == -1)
	{
		printf("ERROR:vcam open is failed\n");
		return (0);
	}

	//é‘¾å³°å½‡bufferé¨å‹«æ¹´é§?
	ioctl(dma_fd,AMM_WR_CMD_DMA_BASE,&_dma_base);
	printf("_dma_base = %x\n",_dma_base);


	//é„çŠ²çš éºãƒ¥å½› ç€µç‘°ç°²æ¾¶æ ?†•éºãƒ¥å½?  é”›å ç·±é’æ¿î˜»ç’å‰§æ¹¡å?ï½‡æ®‘é¦æ¿æ½ƒé”›?
	dma_base = (unsigned int*) mmap(NULL, HW_REGS_SPAN,
				(PROT_READ | PROT_WRITE),
				MAP_SHARED, fd, _dma_base);

	//virtual camera config bus
	cfg_virtual_base  = (per_virtual_base + ((unsigned long)(ALT_LWFPGASLVS_OFST + VIRTUAL_CAMERA_BASE) & (unsigned long)(HW_REGS_MASK)));
	*(cfg_virtual_base+2) = _dma_base;	//éšæ…Lç»”îˆšå•“éî™ŠDR3æ¶“ç‘½ufferé©å“„æ¹´é§?éŠ??

	//é€„¤ç°?–²å©ƒæ–
	*virtual_base = per_virtual_base;
	return fd;

}

int main ()
{
	int virtual_base;
	int i;
	int fd;
	int reg_status = 0;  //read the status register through config bus.

	int *p0 = NULL,*p1 = NULL;


	fd = fpga_init(&virtual_base);
	printf("virtual_base = %x\n",virtual_base);

	*(cfg_virtual_base+1) = 0x00000000;	//æµ£èƒ¯å…˜PLç»??
	usleep(1000);

	p0 = (int *)(dma_base + 0);
	p1 = (int *)(dma_base + IMG_SIZE);

	*(cfg_virtual_base+1) = 0x00000001;	//æµ£èƒ¯å…˜PLç»??

	int buf0[IMG_SIZE],buf1[IMG_SIZE];

	while(1)
	{
		reg_status = *cfg_virtual_base;

		if((reg_status & 0x00000003) == 0x00000002)		//å†™buffer0
		{
			printf("reg_status: %x\n",reg_status);

			//éæª…buffer1
			printf("write buffer0\n");
			for(i=0;i<IMG_SIZE;i++)	//IMG_SIZE
			{
				//buf0[i] = i;

				if(i<(IMG_SIZE/4))
					buf0[i] = 0xffffffff;
				else if(i>(IMG_SIZE/4) && i < (IMG_SIZE/2))
					buf0[i] = 0x00ff00ff;
				else if(i>(IMG_SIZE/2) && i < (IMG_SIZE*3/4))
					buf0[i] = 0x00000000;
				else
					buf0[i] = 0x88888888;

			}

			memcpy(p0,buf0,IMG_SIZE*4);	//copyæ•°æ®åˆ°DDR3

			printf("write data at buffer 0 done\n");
			*(cfg_virtual_base+0) = reg_status | 0x00000001;
			usleep(3000000);
		}

//		éæª…uffer0
		else if((reg_status & 0x00000003) == 0x00000001)	//å†™buffer1
		{
			printf("reg_status: %x\n",reg_status);

			//éæª…uffer0
			printf("write buffer1\n");
			for(i=0;i<IMG_SIZE;i++)
			{
				if(i<(IMG_SIZE/4))
					buf1[i] = 0x88888888;
				else if(i>(IMG_SIZE/4) && i < (IMG_SIZE/2))
					buf1[i] = 0x00000000;
				else if(i>(IMG_SIZE/2) && i < (IMG_SIZE*3/4))
					buf1[i] = 0x00ff00ff;
				else
					buf1[i] = 0xffffffff;

			}

			memcpy(p1,buf1,IMG_SIZE*4);	//copyæ•°æ®åˆ°DDR3

			printf("write data at buffer 1 done\n");
			*(cfg_virtual_base) = reg_status | 0x00000002;//éæ¬ç•¬buffer0 ç’å‰§ç–†éå›§ç¹”æµ??
			usleep(3000000);
		}
		/*
		FILE* hlsInput = fopen("hlsInput.txt", "w+");
		fprintf(hlsInput, "=HLS input=====================================================================\r\n\n");
		for(i=0;i<IMG_SIZE;i++)
		{
			fprintf(hlsInput, "%d:%#x\r",i,dma_base[i]);
			if(IMG_SIZE%10==0)
			{
				fprintf(hlsInput, "\n");
			}
		}
		*/
		//fclose(hlsInput);
	}

	if(munmap(virtual_base,HW_REGS_SPAN) == -1)
	{
		printf("ERROR:munmap is failed\n");
		close(fd);
	}
	//éæŠ½æ£?
	close(fd);
	return 0;

}




